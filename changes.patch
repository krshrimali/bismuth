diff --git a/src/config/bismuth_config.kcfg b/src/config/bismuth_config.kcfg
index f4e57ede..b0ebeea4 100644
--- a/src/config/bismuth_config.kcfg
+++ b/src/config/bismuth_config.kcfg
@@ -48,6 +48,11 @@
       <default>false</default>
     </entry>

+    <entry name="enableVerticalTileLayout" type="Bool">
+      <label>Enable/disable Vertical Tile layout</label>
+      <default>false</default>
+    </entry>
+
     <entry name="ignoreActivity" type="String">
       <label>Do not apply tiling on some activities(comma-separated list of activity names)</label>
       <default></default>
@@ -163,6 +168,11 @@
       <default>0</default>
     </entry>

+    <entry name="smartGaps" type="Bool">
+      <label>Hide gaps if showing a single window</label>
+      <default>false</default>
+    </entry>
+
     <entry name="limitTileWidth" type="Bool">
       <label>Limit the width of tiles</label>
       <default>false</default>
diff --git a/src/kcm/package/contents/ui/Appearance.qml b/src/kcm/package/contents/ui/Appearance.qml
index 7be410aa..8f81a58e 100644
--- a/src/kcm/package/contents/ui/Appearance.qml
+++ b/src/kcm/package/contents/ui/Appearance.qml
@@ -41,6 +41,11 @@ Kirigami.FormLayout {
         Kirigami.FormData.label: "Inner Gaps"
     }

+    BIC.ConfigCheckBox {
+        text: i18n("Hide gaps if showing a single window")
+        settingName: "smartGaps"
+      }
+
     BIC.PixelsConfigSpinBox {
         Kirigami.FormData.label: i18n("All:")
         settingName: "tileLayoutGap"
diff --git a/src/kcm/package/contents/ui/views/Layouts.qml b/src/kcm/package/contents/ui/views/Layouts.qml
index cd59dc1d..b41810b6 100644
--- a/src/kcm/package/contents/ui/views/Layouts.qml
+++ b/src/kcm/package/contents/ui/views/Layouts.qml
@@ -57,6 +57,10 @@ Kirigami.Page {
             settingName: "enableFloatingLayout"
         }

+        ListElement {
+            name: "Vertical Tile"
+            settingName: "enableVerticalTileLayout"
+        }
     }

     KCM.ScrollView {
diff --git a/src/kwinscript/config.ts b/src/kwinscript/config.ts
index 4241ec03..a8ac8fca 100644
--- a/src/kwinscript/config.ts
+++ b/src/kwinscript/config.ts
@@ -26,6 +26,7 @@ export interface Config {
   screenGapRight: number;
   screenGapTop: number;
   tileLayoutGap: number;
+  smartGaps: boolean;
   //#endregion

   //#region Behavior
diff --git a/src/kwinscript/controller/index.ts b/src/kwinscript/controller/index.ts
index aae1af0d..83b72b14 100644
--- a/src/kwinscript/controller/index.ts
+++ b/src/kwinscript/controller/index.ts
@@ -3,18 +3,18 @@
 //
 // SPDX-License-Identifier: MIT

-import { Engine, EngineImpl } from "../engine";
-import { EngineWindow } from "../engine/window";
-import { WindowState } from "../engine/window";
+import { Engine, EngineImpl } from '../engine'
+import { EngineWindow } from '../engine/window'
+import { WindowState } from '../engine/window'

-import { Driver, DriverImpl } from "../driver";
-import { DriverSurface } from "../driver/surface";
+import { Driver, DriverImpl } from '../driver'
+import { DriverSurface } from '../driver/surface'

-import { Config } from "../config";
-import { Log } from "../util/log";
+import { Config } from '../config'
+import { Log } from '../util/log'

-import * as Action from "./action";
-import { TSProxy } from "../extern/proxy";
+import * as Action from './action'
+import { TSProxy } from '../extern/proxy'

 /**
  * Entry point of the script (apart from QML). Handles the user input (shortcuts)
@@ -28,16 +28,16 @@ export interface Controller {
   /**
    * A bunch of surfaces, that represent the user's screens.
    */
-  readonly screens: DriverSurface[];
+  readonly screens: DriverSurface[]
   /**
    * Current active window. In other words the window, that has focus.
    */
-  currentWindow: EngineWindow | null;
+  currentWindow: EngineWindow | null

   /**
    * Current screen. In other words the screen, that has focus.
    */
-  currentSurface: DriverSurface;
+  currentSurface: DriverSurface

   /**
    * Show a popup notification in the center of the screen.
@@ -45,29 +45,29 @@ export interface Controller {
    * @param icon an optional name of the icon to display in the pop-up.
    * @param hint an optional string displayed beside the main text.
    */
-  showNotification(text: string, icon?: string, hint?: string): void;
+  showNotification(text: string, icon?: string, hint?: string): void

   /**
    * React to screen focus change
    */
-  onCurrentSurfaceChanged(): void;
+  onCurrentSurfaceChanged(): void

   /**
    * React to screen update. For example, when the new screen has connected.
    */
-  onSurfaceUpdate(): void;
+  onSurfaceUpdate(): void

   /**
    * React to window geometry update
    * @param window the window whose geometry has changed
    */
-  onWindowGeometryChanged(window: EngineWindow): void;
+  onWindowGeometryChanged(window: EngineWindow): void

   /**
    * React to window resizing
    * @param window the window which is resized
    */
-  onWindowResize(window: EngineWindow): void;
+  onWindowResize(window: EngineWindow): void

   /**
    * React to window resize operation start. The window
@@ -75,7 +75,7 @@ export interface Controller {
    * the window with the mouse by the window edges.
    * @param window the window which is being resized
    */
-  onWindowResizeStart(window: EngineWindow): void;
+  onWindowResizeStart(window: EngineWindow): void

   /**
    * React to window resize operation end. The window
@@ -83,35 +83,35 @@ export interface Controller {
    * the window.
    * @param window the window which was dropped
    */
-  onWindowResizeOver(window: EngineWindow): void;
+  onWindowResizeOver(window: EngineWindow): void

   /**
    * React to window addition
    * @param window new added window
    */
-  onWindowAdded(window: EngineWindow): void;
+  onWindowAdded(window: EngineWindow): void

   /**
    * React to window removal
    * @param window the window which was removed
    */
-  onWindowRemoved(window: EngineWindow): void;
+  onWindowRemoved(window: EngineWindow): void

   /**
    * React to window maximization state change
    * @param window the window whose maximization state changed
    * @param maximized new maximization state
    */
-  onWindowMaximizeChanged(window: EngineWindow, maximized: boolean): void;
+  onWindowMaximizeChanged(window: EngineWindow, maximized: boolean): void

   // TODO: add docs
-  onWindowChanged(window: EngineWindow | null, comment?: string): void;
+  onWindowChanged(window: EngineWindow | null, comment?: string): void

   /**
    * React to window being moved.
    * @param window the window, which it being moved.
    */
-  onWindowMove(window: EngineWindow): void;
+  onWindowMove(window: EngineWindow): void

   /**
    * React to window move operation start. The move operation starts
@@ -119,7 +119,7 @@ export interface Controller {
    * the mouse's button being pressed
    * @param window the window which is being dragged
    */
-  onWindowMoveStart(window: EngineWindow): void;
+  onWindowMoveStart(window: EngineWindow): void

   /**
    * React to window move operation over. The move operation ends
@@ -127,36 +127,36 @@ export interface Controller {
    * the mouse's button being released.
    * @param window the window which was being dragged
    */
-  onWindowMoveOver(window: EngineWindow): void;
+  onWindowMoveOver(window: EngineWindow): void

   /**
    * React to the window gaining focus, attention and love it deserves ❤️
    * @param window the window which received the focus
    */
-  onWindowFocused(window: EngineWindow): void;
+  onWindowFocused(window: EngineWindow): void

   /**
    * React to the window shade state change
    * @param window the window whose state was changed
    */
-  onWindowShadeChanged(window: EngineWindow): void;
+  onWindowShadeChanged(window: EngineWindow): void

   /**
    * Ask engine to manage the window
    * @param win the window which needs to be managed.
    */
-  manageWindow(win: EngineWindow): void;
+  manageWindow(win: EngineWindow): void

   /**
    * The function is called when the script is destroyed.
    * In particular, it's called by QML Component.onDestroyed
    */
-  drop(): void;
+  drop(): void
 }

 export class ControllerImpl implements Controller {
-  private engine: Engine;
-  private driver: Driver;
+  private engine: Engine
+  private driver: Driver
   public constructor(
     qmlObjects: Bismuth.Qml.Main,
     kwinApi: KWin.Api,
@@ -164,93 +164,93 @@ export class ControllerImpl implements Controller {
     private log: Log,
     private proxy: TSProxy
   ) {
-    this.engine = new EngineImpl(this, config, log);
-    this.driver = new DriverImpl(qmlObjects, kwinApi, this, config, log, proxy);
+    this.engine = new EngineImpl(this, config, log)
+    this.driver = new DriverImpl(qmlObjects, kwinApi, this, config, log, proxy)
   }

   /**
    * Entry point: start tiling window management
    */
   public start(): void {
-    this.driver.bindEvents();
-    this.bindShortcuts();
+    this.driver.bindEvents()
+    this.bindShortcuts()

-    this.driver.manageWindows();
+    this.driver.manageWindows()

-    this.engine.arrange();
+    this.engine.arrange()
   }

   public get screens(): DriverSurface[] {
-    return this.driver.screens;
+    return this.driver.screens
   }

   public get currentWindow(): EngineWindow | null {
-    return this.driver.currentWindow;
+    return this.driver.currentWindow
   }

   public set currentWindow(value: EngineWindow | null) {
-    this.driver.currentWindow = value;
+    this.driver.currentWindow = value
   }

   public get currentSurface(): DriverSurface {
-    return this.driver.currentSurface;
+    return this.driver.currentSurface
   }

   public set currentSurface(value: DriverSurface) {
-    this.driver.currentSurface = value;
+    this.driver.currentSurface = value
   }

   public showNotification(text: string, icon?: string, hint?: string): void {
-    this.driver.showNotification(text, icon, hint);
+    this.driver.showNotification(text, icon, hint)
   }

   public onSurfaceUpdate(): void {
-    this.engine.arrange();
+    this.engine.arrange()
   }

   public onCurrentSurfaceChanged(): void {
-    this.log.log(["onCurrentSurfaceChanged", { srf: this.currentSurface }]);
-    this.engine.arrange();
+    this.log.log(['onCurrentSurfaceChanged', { srf: this.currentSurface }])
+    this.engine.arrange()
   }

   public onWindowAdded(window: EngineWindow): void {
-    this.log.log(["onWindowAdded", { window }]);
-    this.engine.manage(window);
+    this.log.log(['onWindowAdded', { window }])
+    this.engine.manage(window)

     /* move window to next surface if the current surface is "full" */
     if (window.tileable) {
-      const srf = this.currentSurface;
-      const tiles = this.engine.windows.visibleTiledWindowsOn(srf);
-      const layoutCapacity = this.engine.layouts.getCurrentLayout(srf).capacity;
+      const srf = this.currentSurface
+      const tiles = this.engine.windows.visibleTiledWindowsOn(srf)
+      const layoutCapacity = this.engine.layouts.getCurrentLayout(srf).capacity
       if (layoutCapacity !== undefined && tiles.length > layoutCapacity) {
-        const nextSurface = this.currentSurface.next();
+        const nextSurface = this.currentSurface.next()
         if (nextSurface) {
           // (window.window as KWinWindow).client.desktop = (nextSurface as KWinSurface).desktop;
-          window.surface = nextSurface;
-          this.currentSurface = nextSurface;
+          window.surface = nextSurface
+          this.currentSurface = nextSurface
         }
       }
     }

-    this.engine.arrange();
+    this.engine.arrange()
   }

   public onWindowRemoved(window: EngineWindow): void {
-    this.log.log(`[Controller#onWindowRemoved] Window removed: ${window}`);
+    this.log.log(`[Controller#onWindowRemoved] Window removed: ${window}`)

-    this.engine.unmanage(window);
+    this.engine.unmanage(window)

     if (this.engine.isLayoutMonocleAndMinimizeRest()) {
       // Switch to the next window if needed
       if (!this.currentWindow) {
         this.log.log(
           `[Controller#onWindowRemoved] Switching to the minimized window`
-        );
-        this.engine.focusOrder(1, true);
+        )
+        this.engine.focusOrder(1, true)
       }
     }

-    this.engine.arrange();
+    this.engine.arrange()
   }

   public onWindowMoveStart(_window: EngineWindow): void {
@@ -262,45 +262,45 @@ export class ControllerImpl implements Controller {
   }

   public onWindowMoveOver(window: EngineWindow): void {
-    this.log.log(["onWindowMoveOver", { window }]);
+    this.log.log(['onWindowMoveOver', { window }])

     /* swap window by dragging */
     if (window.state === WindowState.Tiled) {
       const tiles = this.engine.windows.visibleTiledWindowsOn(
         this.currentSurface
-      );
-      const windowCenter = window.actualGeometry.center;
+      )
+      const windowCenter = window.actualGeometry.center

       const targets = tiles.filter(
         (tile) =>
           tile !== window && tile.actualGeometry.includesPoint(windowCenter)
-      );
+      )

       if (targets.length === 1) {
-        this.engine.windows.swap(window, targets[0]);
-        this.engine.arrange();
-        return;
+        this.engine.windows.swap(window, targets[0])
+        this.engine.arrange()
+        return
       }
     }

     /* ... or float window */
     if (this.config.untileByDragging) {
       if (window.state === WindowState.Tiled) {
-        const diff = window.actualGeometry.subtract(window.geometry);
-        const distance = Math.sqrt(diff.x ** 2 + diff.y ** 2);
+        const diff = window.actualGeometry.subtract(window.geometry)
+        const distance = Math.sqrt(diff.x ** 2 + diff.y ** 2)
         // TODO: arbitrary constant
         if (distance > 30) {
-          window.floatGeometry = window.actualGeometry;
-          window.state = WindowState.Floating;
-          this.engine.arrange();
-          this.engine.showNotification("Window Untiled");
-          return;
+          window.floatGeometry = window.actualGeometry
+          window.state = WindowState.Floating
+          this.engine.arrange()
+          this.engine.showNotification('Window Untiled')
+          return
         }
       }
     }

     /* ... or return to the previous position */
-    window.commit();
+    window.commit()
   }

   public onWindowResizeStart(_window: EngineWindow): void {
@@ -308,22 +308,22 @@ export class ControllerImpl implements Controller {
   }

   public onWindowResize(win: EngineWindow): void {
-    this.log.log(`[Controller#onWindowResize] Window is resizing: ${win}`);
+    this.log.log(`[Controller#onWindowResize] Window is resizing: ${win}`)

     if (win.state === WindowState.Tiled) {
-      this.engine.adjustLayout(win);
-      this.engine.arrange();
+      this.engine.adjustLayout(win)
+      this.engine.arrange()
     }
   }

   public onWindowResizeOver(win: EngineWindow): void {
     this.log.log(
       `[Controller#onWindowResizeOver] Window resize is over: ${win}`
-    );
+    )

     if (win.tiled) {
-      this.engine.adjustLayout(win);
-      this.engine.arrange();
+      this.engine.adjustLayout(win)
+      this.engine.arrange()
     }
   }

@@ -331,58 +331,58 @@ export class ControllerImpl implements Controller {
     _window: EngineWindow,
     _maximized: boolean
   ): void {
-    this.engine.arrange();
+    this.engine.arrange()
   }

   public onWindowGeometryChanged(window: EngineWindow): void {
-    this.log.log(["onWindowGeometryChanged", { window }]);
-    this.engine.enforceSize(window);
+    this.log.log(['onWindowGeometryChanged', { window }])
+    this.engine.enforceSize(window)
   }

   // NOTE: accepts `null` to simplify caller. This event is a catch-all hack
   // by itself anyway.
   public onWindowChanged(window: EngineWindow | null, comment?: string): void {
     if (window) {
-      this.log.log(["onWindowChanged", { window, comment }]);
+      this.log.log(['onWindowChanged', { window, comment }])

-      if (comment === "unminimized") {
-        this.currentWindow = window;
+      if (comment === 'unminimized') {
+        this.currentWindow = window
       }

-      this.engine.arrange();
+      this.engine.arrange()
     }
   }

   public onWindowFocused(win: EngineWindow): void {
-    win.timestamp = new Date().getTime();
+    win.timestamp = new Date().getTime()

     // Minimize other windows if Monocle and config.monocleMinimizeRest
     if (this.engine.isLayoutMonocleAndMinimizeRest()) {
-      this.engine.minimizeOthers(win);
+      this.engine.minimizeOthers(win)
     }
   }

   public onWindowShadeChanged(win: EngineWindow): void {
-    this.log.log(`onWindowShadeChanged, window: ${win}`);
+    this.log.log(`onWindowShadeChanged, window: ${win}`)

     // NOTE: Float shaded windows and change their state back once unshaded
     // For some reason shaded windows break our tiling geometry,
     // once resized. To avoid that, we put them to floating state.
     if (win.shaded) {
-      win.state = WindowState.Floating;
+      win.state = WindowState.Floating
     } else {
-      win.state = win.statePreviouslyAskedToChangeTo;
+      win.state = win.statePreviouslyAskedToChangeTo
     }

-    this.engine.arrange();
+    this.engine.arrange()
   }

   public manageWindow(win: EngineWindow): void {
-    this.engine.manage(win);
+    this.engine.manage(win)
   }

   public drop(): void {
-    this.driver.drop();
+    this.driver.drop()
   }

   private bindShortcuts(): void {
@@ -424,14 +424,15 @@ export class ControllerImpl implements Controller {
       new Action.ToggleFloatingLayout(this.engine, this.log),
       new Action.ToggleQuarterLayout(this.engine, this.log),
       new Action.ToggleSpiralLayout(this.engine, this.log),
+      new Action.ToggleVerticalTileLayout(this.engine, this.log),

       new Action.Rotate(this.engine, this.log),
       new Action.RotateReverse(this.engine, this.log),
       new Action.RotatePart(this.engine, this.log),
-    ];
+    ]

     for (const action of allPossibleActions) {
-      this.proxy.registerShortcut(action);
+      this.proxy.registerShortcut(action)
     }
   }
 }
diff --git a/src/kwinscript/driver/window.ts b/src/kwinscript/driver/window.ts
index ecc8f3a1..c86fbf73 100644
--- a/src/kwinscript/driver/window.ts
+++ b/src/kwinscript/driver/window.ts
@@ -3,13 +3,13 @@
 //
 // SPDX-License-Identifier: MIT

-import { DriverSurface, DriverSurfaceImpl } from "./surface";
+import { DriverSurface, DriverSurfaceImpl } from './surface'

-import { Rect } from "../util/rect";
-import { clip, matchWords } from "../util/func";
-import { Config } from "../config";
-import { Log } from "../util/log";
-import { TSProxy } from "../extern/proxy";
+import { Rect } from '../util/rect'
+import { clip, matchWords } from '../util/func'
+import { Config } from '../config'
+import { Log } from '../util/log'
+import { TSProxy } from '../extern/proxy'

 /**
  * KWin window representation.
@@ -18,62 +18,62 @@ export interface DriverWindow {
   /**
    * Is the window is currently set to be fullscreen
    */
-  readonly fullScreen: boolean;
+  readonly fullScreen: boolean

   /**
    * Window geometry: its coordinates, width and height
    */
-  readonly geometry: Readonly<Rect>;
+  readonly geometry: Readonly<Rect>

   /**
    * Window unique id
    */
-  readonly id: string;
+  readonly id: string

   /**
    * Whether it window is in maximized state
    */
-  readonly maximized: boolean;
+  readonly maximized: boolean

   /**
    * Whether the window should be completely ignored by the script
    */
-  readonly shouldIgnore: boolean;
+  readonly shouldIgnore: boolean

   /**
    * Whether the window should float according to the some predefined rules
    */
-  readonly shouldFloat: boolean;
+  readonly shouldFloat: boolean

   /**
    * The screen number the window is currently at
    */
-  readonly screen: number;
+  readonly screen: number

   /**
    * Whether the window is focused right now
    */
-  readonly active: boolean;
+  readonly active: boolean

   /**
    * Whether the window is a dialog window
    */
-  readonly isDialog: boolean;
+  readonly isDialog: boolean

   /**
    * Window's current surface
    */
-  surface: DriverSurface;
+  surface: DriverSurface

   /**
    * Whether the window is minimized
    */
-  minimized: boolean;
+  minimized: boolean

   /**
    * Whether the window is shaded
    */
-  shaded: boolean;
+  shaded: boolean

   /**
    * Commit the window properties to the KWin, i.e. "show the results of our manipulations to the user"
@@ -81,51 +81,51 @@ export interface DriverWindow {
    * @param noBorder
    * @param keepAbove
    */
-  commit(geometry?: Rect, noBorder?: boolean, keepAbove?: boolean): void;
+  commit(geometry?: Rect, noBorder?: boolean, keepAbove?: boolean): void

   /**
    * Whether the window is visible on the specified surface
    * @param surf the surface to check against
    */
-  visibleOn(surf: DriverSurface): boolean;
+  visibleOn(surf: DriverSurface): boolean
 }

 export class DriverWindowImpl implements DriverWindow {
-  public readonly id: string;
+  public readonly id: string

   public get fullScreen(): boolean {
-    return this.client.fullScreen;
+    return this.client.fullScreen
   }

   public get geometry(): Rect {
-    return Rect.fromQRect(this.client.frameGeometry);
+    return Rect.fromQRect(this.client.frameGeometry)
   }

   public get active(): boolean {
-    return this.client.active;
+    return this.client.active
   }

   public get shouldIgnore(): boolean {
-    const resourceClass = String(this.client.resourceClass);
-    const resourceName = String(this.client.resourceName);
-    const windowRole = String(this.client.windowRole);
+    const resourceClass = String(this.client.resourceClass)
+    const resourceName = String(this.client.resourceName)
+    const windowRole = String(this.client.windowRole)
     return (
       this.client.specialWindow ||
-      resourceClass === "plasmashell" ||
-      resourceClass === "ksmserver" ||
-      resourceClass === "org.kde.plasmashell" ||
-      resourceClass === "krunner" ||
-      resourceClass === "kded5" ||
+      resourceClass === 'plasmashell' ||
+      resourceClass === 'ksmserver' ||
+      resourceClass === 'org.kde.plasmashell' ||
+      resourceClass === 'krunner' ||
+      resourceClass === 'kded5' ||
       this.config.ignoreClass.indexOf(resourceClass) >= 0 ||
       this.config.ignoreClass.indexOf(resourceName) >= 0 ||
       matchWords(this.client.caption, this.config.ignoreTitle) >= 0 ||
       this.config.ignoreRole.indexOf(windowRole) >= 0
-    );
+    )
   }

   public get shouldFloat(): boolean {
-    const resourceClass = String(this.client.resourceClass);
-    const resourceName = String(this.client.resourceName);
+    const resourceClass = String(this.client.resourceClass)
+    const resourceName = String(this.client.resourceName)
     return (
       this.client.modal ||
       !this.client.resizeable ||
@@ -137,44 +137,44 @@ export class DriverWindowImpl implements DriverWindow {
       this.config.floatingClass.indexOf(resourceClass) >= 0 ||
       this.config.floatingClass.indexOf(resourceName) >= 0 ||
       matchWords(this.client.caption, this.config.floatingTitle) >= 0
-    );
+    )
   }

   public get screen(): number {
-    return this.client.screen;
+    return this.client.screen
   }

   public get minimized(): boolean {
-    return this.client.minimized;
+    return this.client.minimized
   }

   public set minimized(min: boolean) {
-    this.client.minimized = min;
+    this.client.minimized = min
   }

   public get shaded(): boolean {
-    return this.client.shade;
+    return this.client.shade
   }

-  public maximized: boolean;
+  public maximized: boolean

   public get surface(): DriverSurface {
-    let activity;
+    let activity
     if (this.client.activities.length === 0) {
-      activity = this.proxy.workspace().currentActivity;
+      activity = this.proxy.workspace().currentActivity
     } else if (
       this.client.activities.indexOf(this.proxy.workspace().currentActivity) >=
       0
     ) {
-      activity = this.proxy.workspace().currentActivity;
+      activity = this.proxy.workspace().currentActivity
     } else {
-      activity = this.client.activities[0];
+      activity = this.client.activities[0]
     }

     const desktop =
       this.client.desktop >= 0
         ? this.client.desktop
-        : this.proxy.workspace().currentDesktop;
+        : this.proxy.workspace().currentDesktop

     return new DriverSurfaceImpl(
       this.client.screen,
@@ -183,21 +183,21 @@ export class DriverWindowImpl implements DriverWindow {
       this.qml.activityInfo,
       this.config,
       this.proxy
-    );
+    )
   }

   public set surface(surf: DriverSurface) {
-    const surfImpl = surf as DriverSurfaceImpl;
+    const surfImpl = surf as DriverSurfaceImpl

     // TODO: setting activity?
     // TODO: setting screen = move to the screen
     if (this.client.desktop !== surfImpl.desktop) {
-      this.client.desktop = surfImpl.desktop;
+      this.client.desktop = surfImpl.desktop
     }
   }

-  private noBorderManaged: boolean;
-  private noBorderOriginal: boolean;
+  private noBorderManaged: boolean
+  private noBorderOriginal: boolean

   /**
    * Create a window from the KWin client object
@@ -214,14 +214,14 @@ export class DriverWindowImpl implements DriverWindow {
     private log: Log,
     private proxy: TSProxy
   ) {
-    this.id = DriverWindowImpl.generateID(client);
-    this.maximized = false;
-    this.noBorderManaged = false;
-    this.noBorderOriginal = client.noBorder;
+    this.id = DriverWindowImpl.generateID(client)
+    this.maximized = false
+    this.noBorderManaged = false
+    this.noBorderOriginal = client.noBorder
   }

   public static generateID(client: KWin.Client): string {
-    return `${String(client)}/${client.windowId}`;
+    return `${String(client)}/${client.windowId}`
   }

   public commit(
@@ -240,37 +240,39 @@ export class DriverWindowImpl implements DriverWindow {
     // );

     if (this.client.move || this.client.resize) {
-      return;
+      return
     }

     if (noBorder !== undefined) {
       if (!this.noBorderManaged && noBorder) {
         /* Backup border state when transitioning from unmanaged to managed */
-        this.noBorderOriginal = this.client.noBorder;
+        // this.noBorderOriginal = this.client.noBorder;
+        this.noBorderOriginal = false
       } else if (this.noBorderManaged && !this.client.noBorder) {
         /* If border is enabled while in managed mode, remember it.
          * Note that there's no way to know if border is re-disabled in managed mode. */
-        this.noBorderOriginal = false;
+        this.noBorderOriginal = false
       }

       if (noBorder) {
         /* (Re)entering managed mode: remove border. */
-        this.client.noBorder = true;
+        this.client.noBorder = true
       } else if (this.noBorderManaged) {
         /* Exiting managed mode: restore original value. */
-        this.client.noBorder = this.noBorderOriginal;
+        // this.client.noBorder = this.noBorderOriginal
+        this.client.noBorder = false
       }

       /* update mode */
-      this.noBorderManaged = noBorder;
+      this.noBorderManaged = noBorder
     }

     if (keepAbove !== undefined) {
-      this.client.keepAbove = keepAbove;
+      this.client.keepAbove = keepAbove
     }

     if (geometry !== undefined) {
-      geometry = this.adjustGeometry(geometry);
+      geometry = this.adjustGeometry(geometry)
       if (this.config.preventProtrusion) {
         const area = Rect.fromQRect(
           this.proxy.workspace().clientArea(
@@ -278,16 +280,16 @@ export class DriverWindowImpl implements DriverWindow {
             this.client.screen,
             this.proxy.workspace().currentDesktop
           )
-        );
+        )
         if (!area.includes(geometry)) {
           /* assume windows will extrude only through right and bottom edges */
-          const x = geometry.x + Math.min(area.maxX - geometry.maxX, 0);
-          const y = geometry.y + Math.min(area.maxY - geometry.maxY, 0);
-          geometry = new Rect(x, y, geometry.width, geometry.height);
-          geometry = this.adjustGeometry(geometry);
+          const x = geometry.x + Math.min(area.maxX - geometry.maxX, 0)
+          const y = geometry.y + Math.min(area.maxY - geometry.maxY, 0)
+          geometry = new Rect(x, y, geometry.width, geometry.height)
+          geometry = this.adjustGeometry(geometry)
         }
       }
-      this.client.frameGeometry = geometry.toQRect();
+      this.client.frameGeometry = geometry.toQRect()
     }
   }

@@ -295,11 +297,11 @@ export class DriverWindowImpl implements DriverWindow {
     // Using a shorthand name to keep debug message tidy
     return `KWin(${this.client.windowId.toString(16)}.${
       this.client.resourceClass
-    })`;
+    })`
   }

   public visibleOn(surf: DriverSurface): boolean {
-    const surfImpl = surf as DriverSurfaceImpl;
+    const surfImpl = surf as DriverSurfaceImpl
     return (
       !this.client.minimized &&
       (this.client.desktop === surfImpl.desktop ||
@@ -307,7 +309,7 @@ export class DriverWindowImpl implements DriverWindow {
       (this.client.activities.length === 0 /* on all activities */ ||
         this.client.activities.indexOf(surfImpl.activity) !== -1) &&
       this.client.screen === surfImpl.screen
-    );
+    )
   }

   /**
@@ -316,27 +318,27 @@ export class DriverWindowImpl implements DriverWindow {
    * @returns
    */
   private adjustGeometry(geometry: Rect): Rect {
-    let width = geometry.width;
-    let height = geometry.height;
+    let width = geometry.width
+    let height = geometry.height

     /* do not resize fixed-size windows */
     if (!this.client.resizeable) {
-      width = this.client.frameGeometry.width;
-      height = this.client.frameGeometry.height;
+      width = this.client.frameGeometry.width
+      height = this.client.frameGeometry.height
     } else {
       /* respect min/max size limit */
-      width = clip(width, this.client.minSize.width, this.client.maxSize.width);
+      width = clip(width, this.client.minSize.width, this.client.maxSize.width)
       height = clip(
         height,
         this.client.minSize.height,
         this.client.maxSize.height
-      );
+      )
     }

-    return new Rect(geometry.x, geometry.y, width, height);
+    return new Rect(geometry.x, geometry.y, width, height)
   }

   public get isDialog(): boolean {
-    return this.client.dialog;
+    return this.client.dialog
   }
 }
diff --git a/src/kwinscript/engine/index.ts b/src/kwinscript/engine/index.ts
index 149c972a..fface176 100644
--- a/src/kwinscript/engine/index.ts
+++ b/src/kwinscript/engine/index.ts
@@ -3,25 +3,25 @@
 //
 // SPDX-License-Identifier: MIT

-import MonocleLayout from "./layout/monocle_layout";
+import MonocleLayout from './layout/monocle_layout'

-import LayoutStore from "./layout_store";
-import { WindowStore, WindowStoreImpl } from "./window_store";
-import { EngineWindow, EngineWindowImpl, WindowState } from "./window";
+import LayoutStore from './layout_store'
+import { WindowStore, WindowStoreImpl } from './window_store'
+import { EngineWindow, EngineWindowImpl, WindowState } from './window'

-import { Controller } from "../controller";
+import { Controller } from '../controller'

-import { DriverSurface } from "../driver/surface";
+import { DriverSurface } from '../driver/surface'

-import { Rect, RectDelta } from "../util/rect";
-import { overlap, wrapIndex } from "../util/func";
-import { Config } from "../config";
-import { Log } from "../util/log";
-import { WindowsLayout } from "./layout";
+import { Rect, RectDelta } from '../util/rect'
+import { overlap, wrapIndex } from '../util/func'
+import { Config } from '../config'
+import { Log } from '../util/log'
+import { WindowsLayout } from './layout'

-export type Direction = "up" | "down" | "left" | "right";
-export type CompassDirection = "east" | "west" | "south" | "north";
-export type Step = -1 | 1;
+export type Direction = 'up' | 'down' | 'left' | 'right'
+export type CompassDirection = 'east' | 'west' | 'south' | 'north'
+export type Step = -1 | 1

 /**
  * Maintains tiling context and performs various tiling actions.
@@ -30,27 +30,27 @@ export interface Engine {
   /**
    * All the layouts currently available
    */
-  layouts: LayoutStore;
+  layouts: LayoutStore

   /**
    * All the windows we are interested in
    */
-  windows: WindowStore;
+  windows: WindowStore

   /**
    * Arrange all the windows on the visible surfaces according to the tiling rules
    */
-  arrange(): void;
+  arrange(): void

   /**
    * Register the given window to WM.
    */
-  manage(window: EngineWindow): void;
+  manage(window: EngineWindow): void

   /**
    * Unregister the given window from WM.
    */
-  unmanage(window: EngineWindow): void;
+  unmanage(window: EngineWindow): void

   /**
    * Adjust layout based on the change in size of a tile.
@@ -60,21 +60,21 @@ export interface Engine {
    *
    * Used when tile is resized using mouse.
    */
-  adjustLayout(basis: EngineWindow): void;
+  adjustLayout(basis: EngineWindow): void

   /**
    * Resize the current floating window.
    *
    * @param window a floating window
    */
-  resizeFloat(window: EngineWindow, dir: CompassDirection, step: Step): void;
+  resizeFloat(window: EngineWindow, dir: CompassDirection, step: Step): void

   /**
    * Resize the current tile by adjusting the layout.
    *
    * Used by grow/shrink shortcuts.
    */
-  resizeTile(basis: EngineWindow, dir: CompassDirection, step: Step): void;
+  resizeTile(basis: EngineWindow, dir: CompassDirection, step: Step): void

   /**
    * Resize the given window, by moving border inward or outward.
@@ -84,7 +84,7 @@ export interface Engine {
    * @param dir which border
    * @param step which direction. 1 means outward, -1 means inward.
    */
-  resizeWindow(window: EngineWindow, dir: CompassDirection, step: Step): void;
+  resizeWindow(window: EngineWindow, dir: CompassDirection, step: Step): void

   /**
    * Re-apply window geometry, computed by layout algorithm.
@@ -93,36 +93,36 @@ export interface Engine {
    * which is straight against the purpose of tiling WM. This operation
    * move/resize such windows back to where/how they should be.
    */
-  enforceSize(window: EngineWindow): void;
+  enforceSize(window: EngineWindow): void

   /**
    * @returns the layout we have on the surface of the active window
    */
-  currentLayoutOnCurrentSurface(): WindowsLayout;
+  currentLayoutOnCurrentSurface(): WindowsLayout

   /**
    * @returns the active window
    */
-  currentWindow(): EngineWindow | null;
+  currentWindow(): EngineWindow | null

   /**
    * Focus next or previous window
    * @param step Direction to step in (1=forward, -1=backward)
    * @param includeHidden Whether to step through (true) or skip over (false) minimized windows
    */
-  focusOrder(step: Step, includeHidden: boolean): void;
+  focusOrder(step: Step, includeHidden: boolean): void

   /**
    * Focus a neighbor at the given direction.
    */
-  focusDir(dir: Direction): void;
+  focusDir(dir: Direction): void

   /**
    * Swap the position of the current window with the next or previous window.
    */
-  swapOrder(window: EngineWindow, step: Step): void;
+  swapOrder(window: EngineWindow, step: Step): void

-  swapDirOrMoveFloat(dir: Direction): void;
+  swapDirOrMoveFloat(dir: Direction): void

   /**
    * Set the current window as the "master".
@@ -131,33 +131,33 @@ export interface Engine {
    * Some layouts depend on this assumption, and will make such windows more
    * visible than others.
    */
-  setMaster(window: EngineWindow): void;
+  setMaster(window: EngineWindow): void

   /**
    * Toggle float mode of window.
    */
-  toggleFloat(window: EngineWindow): void;
+  toggleFloat(window: EngineWindow): void

   /**
    * Change the layout of the current surface to the next.
    */
-  cycleLayout(step: Step): void;
+  cycleLayout(step: Step): void

   /**
    * Set the layout of the current surface to the specified layout.
    */
-  toggleLayout(layoutClassID: string): void;
+  toggleLayout(layoutClassID: string): void

   /**
    * Minimize all windows on the surface except the given window.
    */
-  minimizeOthers(window: EngineWindow): void;
+  minimizeOthers(window: EngineWindow): void

   /**
    * @returns true if the current layout is monocle and the option
    * to minimize other than active windows is enabled
    */
-  isLayoutMonocleAndMinimizeRest(): boolean;
+  isLayoutMonocleAndMinimizeRest(): boolean

   /**
    * Show a popup notification in the center of the screen.
@@ -165,40 +165,43 @@ export interface Engine {
    * @param icon an optional name of the icon to display in the pop-up.
    * @param hint an optional string displayed beside the main text.
    */
-  showNotification(text: string, icon?: string, hint?: string): void;
+  showNotification(text: string, icon?: string, hint?: string): void

   /**
    * Show the notification with the info
    * about the current layout.
    */
-  showLayoutNotification(): void;
+  showLayoutNotification(): void
 }

 export class EngineImpl implements Engine {
-  public layouts: LayoutStore;
-  public windows: WindowStore;
+  public layouts: LayoutStore
+  public windows: WindowStore

   constructor(
     private controller: Controller,
     private config: Config,
     private log: Log
   ) {
-    this.layouts = new LayoutStore(this.config);
-    this.windows = new WindowStoreImpl();
+    this.layouts = new LayoutStore(this.config)
+    this.windows = new WindowStoreImpl()
   }

   public adjustLayout(basis: EngineWindow): void {
-    const srf = basis.surface;
-    const layout = this.layouts.getCurrentLayout(srf);
+    const srf = basis.surface
+    const layout = this.layouts.getCurrentLayout(srf)
     if (layout.adjust) {
-      const area = srf.workingArea.gap(
-        this.config.screenGapLeft,
-        this.config.screenGapRight,
-        this.config.screenGapTop,
-        this.config.screenGapBottom
-      );
-      const tiles = this.windows.visibleTiledWindowsOn(srf);
-      layout.adjust(area, tiles, basis, basis.geometryDelta);
+      const tiles = this.windows.visibleTiledWindowsOn(srf)
+      const noGaps = tiles.length == 1 && this.config.smartGaps
+      const area = noGaps
+        ? srf.workingArea
+        : srf.workingArea.gap(
+            this.config.screenGapLeft,
+            this.config.screenGapRight,
+            this.config.screenGapTop,
+            this.config.screenGapBottom
+          )
+      layout.adjust(area, tiles, basis, basis.geometryDelta)
     }
   }

@@ -207,33 +210,33 @@ export class EngineImpl implements Engine {
     dir: CompassDirection,
     step: Step
   ): void {
-    const srf = window.surface;
+    const srf = window.surface

     // TODO: configurable step size?
-    const hStepSize = srf.workingArea.width * 0.05;
-    const vStepSize = srf.workingArea.height * 0.05;
+    const hStepSize = srf.workingArea.width * 0.05
+    const vStepSize = srf.workingArea.height * 0.05

-    let hStep, vStep;
+    let hStep, vStep
     switch (dir) {
-      case "east":
-        (hStep = step), (vStep = 0);
-        break;
-      case "west":
-        (hStep = -step), (vStep = 0);
-        break;
-      case "south":
-        (hStep = 0), (vStep = step);
-        break;
-      case "north":
-        (hStep = 0), (vStep = -step);
-        break;
+      case 'east':
+        ;(hStep = step), (vStep = 0)
+        break
+      case 'west':
+        ;(hStep = -step), (vStep = 0)
+        break
+      case 'south':
+        ;(hStep = 0), (vStep = step)
+        break
+      case 'north':
+        ;(hStep = 0), (vStep = -step)
+        break
     }

-    const geometry = window.actualGeometry;
-    const width = geometry.width + hStepSize * hStep;
-    const height = geometry.height + vStepSize * vStep;
+    const geometry = window.actualGeometry
+    const width = geometry.width + hStepSize * hStep
+    const height = geometry.height + vStepSize * vStep

-    window.forceSetGeometry(new Rect(geometry.x, geometry.y, width, height));
+    window.forceSetGeometry(new Rect(geometry.x, geometry.y, width, height))
   }

   public resizeTile(
@@ -241,62 +244,61 @@ export class EngineImpl implements Engine {
     dir: CompassDirection,
     step: Step
   ): void {
-    const srf = basis.surface;
+    const srf = basis.surface

-    if (dir === "east") {
-      const maxX = basis.geometry.maxX;
+    if (dir === 'east') {
+      const maxX = basis.geometry.maxX
       const easternNeighbor = this.windows
         .visibleTiledWindowsOn(srf)
-        .filter((tile) => tile.geometry.x >= maxX);
+        .filter((tile) => tile.geometry.x >= maxX)
       if (easternNeighbor.length === 0) {
-        dir = "west";
-        step *= -1;
+        dir = 'west'
+        step *= -1
       }
-    } else if (dir === "south") {
-      const maxY = basis.geometry.maxY;
+    } else if (dir === 'south') {
+      const maxY = basis.geometry.maxY
       const southernNeighbor = this.windows
         .visibleTiledWindowsOn(srf)
-        .filter((tile) => tile.geometry.y >= maxY);
+        .filter((tile) => tile.geometry.y >= maxY)
       if (southernNeighbor.length === 0) {
-        dir = "north";
-        step *= -1;
+        dir = 'north'
+        step *= -1
       }
     }

     // TODO: configurable step size?
-    const hStepSize = srf.workingArea.width * 0.03;
-    const vStepSize = srf.workingArea.height * 0.03;
-    let delta: RectDelta;
+    const hStepSize = srf.workingArea.width * 0.03
+    const vStepSize = srf.workingArea.height * 0.03
+    let delta: RectDelta
     switch (dir) {
-      case "east":
-        delta = new RectDelta(hStepSize * step, 0, 0, 0);
-        break;
-      case "west":
-        delta = new RectDelta(0, hStepSize * step, 0, 0);
-        break;
-      case "south":
-        delta = new RectDelta(0, 0, vStepSize * step, 0);
-        break;
-      case "north": // Pass through
+      case 'east':
+        delta = new RectDelta(hStepSize * step, 0, 0, 0)
+        break
+      case 'west':
+        delta = new RectDelta(0, hStepSize * step, 0, 0)
+        break
+      case 'south':
+        delta = new RectDelta(0, 0, vStepSize * step, 0)
+        break
+      case 'north': // Pass through
       default:
-        delta = new RectDelta(0, 0, 0, vStepSize * step);
-        break;
+        delta = new RectDelta(0, 0, 0, vStepSize * step)
+        break
     }

-    const layout = this.layouts.getCurrentLayout(srf);
+    const layout = this.layouts.getCurrentLayout(srf)
     if (layout.adjust) {
-      const area = srf.workingArea.gap(
-        this.config.screenGapLeft,
-        this.config.screenGapRight,
-        this.config.screenGapTop,
-        this.config.screenGapBottom
-      );
-      layout.adjust(
-        area,
-        this.windows.visibleTileableWindowsOn(srf),
-        basis,
-        delta
-      );
+      const tiles = this.windows.visibleTiledWindowsOn(srf)
+      const noGaps = tiles.length == 1 && this.config.smartGaps
+      const area = noGaps
+        ? srf.workingArea
+        : srf.workingArea.gap(
+            this.config.screenGapLeft,
+            this.config.screenGapRight,
+            this.config.screenGapTop,
+            this.config.screenGapBottom
+          )
+      layout.adjust(area, tiles, basis, delta)
     }
   }

@@ -305,20 +307,20 @@ export class EngineImpl implements Engine {
     dir: CompassDirection,
     step: Step
   ): void {
-    const state = window.state;
+    const state = window.state
     if (EngineWindowImpl.isFloatingState(state)) {
-      this.resizeFloat(window, dir, step);
+      this.resizeFloat(window, dir, step)
     } else if (EngineWindowImpl.isTiledState(state)) {
-      this.resizeTile(window, dir, step);
+      this.resizeTile(window, dir, step)
     }
   }

   public arrange(): void {
-    this.log.log("arrange");
+    this.log.log('arrange')

     this.controller.screens.forEach((driverSurface: DriverSurface) => {
-      this.arrangeScreen(driverSurface);
-    });
+      this.arrangeScreen(driverSurface)
+    })
   }

   /**
@@ -327,29 +329,28 @@ export class EngineImpl implements Engine {
    * @param screenSurface screen's surface, on which windows should be arranged
    */
   public arrangeScreen(screenSurface: DriverSurface): void {
-    const layout = this.layouts.getCurrentLayout(screenSurface);
+    const layout = this.layouts.getCurrentLayout(screenSurface)

-    const workingArea = screenSurface.workingArea;
-    const tilingArea = this.getTilingArea(workingArea, layout);
+    const workingArea = screenSurface.workingArea

-    const visibleWindows = this.windows.visibleWindowsOn(screenSurface);
+    const visibleWindows = this.windows.visibleWindowsOn(screenSurface)
+    const tilingArea = this.getTilingArea(workingArea, layout, visibleWindows)

     // Set correct window state for new windows
     visibleWindows.forEach((win: EngineWindow) => {
       if (win.state === WindowState.Undecided) {
-        win.state = win.shouldFloat ? WindowState.Floating : WindowState.Tiled;
+        win.state = win.shouldFloat ? WindowState.Floating : WindowState.Tiled
       }
-    });
+    })

-    const tileableWindows =
-      this.windows.visibleTileableWindowsOn(screenSurface);
+    const tileableWindows = this.windows.visibleTileableWindowsOn(screenSurface)

     // Maximize sole tile if enabled or apply the current layout as expected
     if (this.config.maximizeSoleTile && tileableWindows.length === 1) {
-      tileableWindows[0].state = WindowState.Maximized;
-      tileableWindows[0].geometry = workingArea;
+      tileableWindows[0].state = WindowState.Maximized
+      tileableWindows[0].geometry = workingArea
     } else if (tileableWindows.length > 0) {
-      layout.apply(this.controller, tileableWindows, tilingArea);
+      layout.apply(this.controller, tileableWindows, tilingArea)
     }

     // If enabled, limit the windows' width
@@ -359,53 +360,53 @@ export class EngineImpl implements Engine {
     ) {
       const maxWidth = Math.floor(
         workingArea.height * this.config.limitTileWidthRatio
-      );
+      )
       tileableWindows
         .filter((tile) => tile.tiled && tile.geometry.width > maxWidth)
         .forEach((tile) => {
-          const g = tile.geometry;
+          const g = tile.geometry
           tile.geometry = new Rect(
             g.x + Math.floor((g.width - maxWidth) / 2),
             g.y,
             maxWidth,
             g.height
-          );
-        });
+          )
+        })
     }

     // Commit window assigned properties
-    visibleWindows.forEach((win: EngineWindow) => win.commit());
-    this.log.log(["arrangeScreen/finished", { screenSurface }]);
+    visibleWindows.forEach((win: EngineWindow) => win.commit())
+    this.log.log(['arrangeScreen/finished', { screenSurface }])
   }

   public currentLayoutOnCurrentSurface(): WindowsLayout {
-    return this.layouts.getCurrentLayout(this.controller.currentSurface);
+    return this.layouts.getCurrentLayout(this.controller.currentSurface)
   }

   public currentWindow(): EngineWindow | null {
-    return this.controller.currentWindow;
+    return this.controller.currentWindow
   }

   public enforceSize(window: EngineWindow): void {
     if (window.tiled && !window.actualGeometry.equals(window.geometry)) {
-      window.commit();
+      window.commit()
     }
   }

   public manage(window: EngineWindow): void {
     if (!window.shouldIgnore) {
       /* engine#arrange will update the state when required. */
-      window.state = WindowState.Undecided;
+      window.state = WindowState.Undecided
       if (this.config.newWindowAsMaster) {
-        this.windows.unshift(window);
+        this.windows.unshift(window)
       } else {
-        this.windows.push(window);
+        this.windows.push(window)
       }
     }
   }

   public unmanage(window: EngineWindow): void {
-    this.windows.remove(window);
+    this.windows.remove(window)
   }

   /**
@@ -414,92 +415,92 @@ export class EngineImpl implements Engine {
    * @param includeHidden whether to switch to or skip minimized windows
    */
   public focusOrder(step: Step, includeHidden = false): void {
-    const window = this.controller.currentWindow;
-    let windows;
+    const window = this.controller.currentWindow
+    let windows

     if (includeHidden) {
-      windows = this.windows.allWindowsOn(this.controller.currentSurface);
+      windows = this.windows.allWindowsOn(this.controller.currentSurface)
     } else {
-      windows = this.windows.visibleWindowsOn(this.controller.currentSurface);
+      windows = this.windows.visibleWindowsOn(this.controller.currentSurface)
     }

     if (windows.length === 0) {
       // Nothing to focus
-      return;
+      return
     }

     /* If no current window, select the first one. */
     if (window === null) {
-      this.controller.currentWindow = windows[0];
-      return;
+      this.controller.currentWindow = windows[0]
+      return
     }

-    const idx = windows.indexOf(window);
+    const idx = windows.indexOf(window)
     if (!window || idx < 0) {
       /* This probably shouldn't happen, but just in case... */
-      this.controller.currentWindow = windows[0];
-      return;
+      this.controller.currentWindow = windows[0]
+      return
     }

-    const num = windows.length;
-    const newIndex = (idx + (step % num) + num) % num;
+    const num = windows.length
+    const newIndex = (idx + (step % num) + num) % num

-    this.controller.currentWindow = windows[newIndex];
+    this.controller.currentWindow = windows[newIndex]
   }

   public focusDir(dir: Direction): void {
-    const window = this.controller.currentWindow;
+    const window = this.controller.currentWindow

     /* if no current window, select the first window. */
     if (window === null) {
       const tiles = this.windows.visibleWindowsOn(
         this.controller.currentSurface
-      );
+      )
       if (tiles.length > 0) {
-        this.controller.currentWindow = tiles[0];
+        this.controller.currentWindow = tiles[0]
       }
-      return;
+      return
     }

-    const neighbor = this.getNeighborByDirection(window, dir);
+    const neighbor = this.getNeighborByDirection(window, dir)
     if (neighbor) {
-      this.controller.currentWindow = neighbor;
+      this.controller.currentWindow = neighbor
     }
   }

   public swapOrder(window: EngineWindow, step: Step): void {
-    const srf = window.surface;
-    const visibles = this.windows.visibleWindowsOn(srf);
+    const srf = window.surface
+    const visibles = this.windows.visibleWindowsOn(srf)
     if (visibles.length < 2) {
-      return;
+      return
     }

-    const vsrc = visibles.indexOf(window);
-    const vdst = wrapIndex(vsrc + step, visibles.length);
-    const dstWin = visibles[vdst];
+    const vsrc = visibles.indexOf(window)
+    const vdst = wrapIndex(vsrc + step, visibles.length)
+    const dstWin = visibles[vdst]

-    this.windows.move(window, dstWin);
+    this.windows.move(window, dstWin)
   }

   /**
    * Swap the position of the current window with a neighbor at the given direction.
    */
   public swapDirection(dir: Direction): void {
-    const window = this.controller.currentWindow;
+    const window = this.controller.currentWindow
     if (window === null) {
       /* if no current window, select the first tile. */
       const tiles = this.windows.visibleTiledWindowsOn(
         this.controller.currentSurface
-      );
+      )
       if (tiles.length > 1) {
-        this.controller.currentWindow = tiles[0];
+        this.controller.currentWindow = tiles[0]
       }
-      return;
+      return
     }

-    const neighbor = this.getNeighborByDirection(window, dir);
+    const neighbor = this.getNeighborByDirection(window, dir)
     if (neighbor) {
-      this.windows.swap(window, neighbor);
+      this.windows.swap(window, neighbor)
     }
   }

@@ -509,71 +510,71 @@ export class EngineImpl implements Engine {
    * @param dir which direction
    */
   public moveFloat(window: EngineWindow, dir: Direction): void {
-    const srf = window.surface;
+    const srf = window.surface

     // TODO: configurable step size?
-    const hStepSize = srf.workingArea.width * 0.05;
-    const vStepSize = srf.workingArea.height * 0.05;
+    const hStepSize = srf.workingArea.width * 0.05
+    const vStepSize = srf.workingArea.height * 0.05

-    let hStep, vStep;
+    let hStep, vStep
     switch (dir) {
-      case "up":
-        (hStep = 0), (vStep = -1);
-        break;
-      case "down":
-        (hStep = 0), (vStep = 1);
-        break;
-      case "left":
-        (hStep = -1), (vStep = 0);
-        break;
-      case "right":
-        (hStep = 1), (vStep = 0);
-        break;
+      case 'up':
+        ;(hStep = 0), (vStep = -1)
+        break
+      case 'down':
+        ;(hStep = 0), (vStep = 1)
+        break
+      case 'left':
+        ;(hStep = -1), (vStep = 0)
+        break
+      case 'right':
+        ;(hStep = 1), (vStep = 0)
+        break
     }

-    const geometry = window.actualGeometry;
-    const x = geometry.x + hStepSize * hStep;
-    const y = geometry.y + vStepSize * vStep;
+    const geometry = window.actualGeometry
+    const x = geometry.x + hStepSize * hStep
+    const y = geometry.y + vStepSize * vStep

-    window.forceSetGeometry(new Rect(x, y, geometry.width, geometry.height));
+    window.forceSetGeometry(new Rect(x, y, geometry.width, geometry.height))
   }

   public swapDirOrMoveFloat(dir: Direction): void {
-    const window = this.controller.currentWindow;
+    const window = this.controller.currentWindow
     if (!window) {
-      return;
+      return
     }

-    const state = window.state;
+    const state = window.state
     if (EngineWindowImpl.isFloatingState(state)) {
-      this.moveFloat(window, dir);
+      this.moveFloat(window, dir)
     } else if (EngineWindowImpl.isTiledState(state)) {
-      this.swapDirection(dir);
+      this.swapDirection(dir)
     }
   }

   public toggleFloat(window: EngineWindow): void {
-    window.state = !window.tileable ? WindowState.Tiled : WindowState.Floating;
+    window.state = !window.tileable ? WindowState.Tiled : WindowState.Floating
   }

   public setMaster(window: EngineWindow): void {
-    this.windows.putWindowToMaster(window);
+    this.windows.putWindowToMaster(window)
   }

   public cycleLayout(step: Step): void {
     const layout = this.layouts.cycleLayout(
       this.controller.currentSurface,
       step
-    );
+    )
     if (layout) {
-      this.showLayoutNotification();
+      this.showLayoutNotification()

       // Minimize inactive windows if Monocle and config.monocleMinimizeRest
       if (
         this.isLayoutMonocleAndMinimizeRest() &&
         this.controller.currentWindow
       ) {
-        this.minimizeOthers(this.controller.currentWindow);
+        this.minimizeOthers(this.controller.currentWindow)
       }
     }
   }
@@ -582,16 +583,16 @@ export class EngineImpl implements Engine {
     const layout = this.layouts.toggleLayout(
       this.controller.currentSurface,
       layoutClassID
-    );
+    )
     if (layout) {
-      this.showLayoutNotification();
+      this.showLayoutNotification()

       // Minimize inactive windows if Monocle and config.monocleMinimizeRest
       if (
         this.isLayoutMonocleAndMinimizeRest() &&
         this.controller.currentWindow
       ) {
-        this.minimizeOthers(this.controller.currentWindow);
+        this.minimizeOthers(this.controller.currentWindow)
       }
     }
   }
@@ -603,9 +604,9 @@ export class EngineImpl implements Engine {
         tile.id !== window.id &&
         this.windows.visibleTiledWindowsOn(window.surface).includes(window)
       ) {
-        tile.minimized = true;
+        tile.minimized = true
       } else {
-        tile.minimized = false;
+        tile.minimized = false
       }
     }
   }
@@ -614,7 +615,7 @@ export class EngineImpl implements Engine {
     return (
       this.currentLayoutOnCurrentSurface() instanceof MonocleLayout &&
       this.config.monocleMinimizeRest
-    );
+    )
   }

   private getNeighborCandidates(
@@ -623,12 +624,12 @@ export class EngineImpl implements Engine {
   ): EngineWindow[] {
     const visibleWindowsOnCurrentSurface = this.windows.visibleTiledWindowsOn(
       this.controller.currentSurface
-    );
+    )

     // Flipping all inputs' signs allows for the same logic to find closest windows in either direction
-    const sign = dir === "down" || dir === "right" ? 1 : -1;
+    const sign = dir === 'down' || dir === 'right' ? 1 : -1

-    if (dir === "up" || dir === "down") {
+    if (dir === 'up' || dir === 'down') {
       return visibleWindowsOnCurrentSurface.filter(
         (window): boolean =>
           window.geometry.y * sign > basis.geometry.y * sign &&
@@ -638,7 +639,7 @@ export class EngineImpl implements Engine {
             window.geometry.x,
             window.geometry.maxX
           )
-      );
+      )
     } else {
       return visibleWindowsOnCurrentSurface.filter(
         (window): boolean =>
@@ -649,7 +650,7 @@ export class EngineImpl implements Engine {
             window.geometry.y,
             window.geometry.maxY
           )
-      );
+      )
     }
   }

@@ -660,18 +661,18 @@ export class EngineImpl implements Engine {
     return windowArray.reduce(
       (prevValue, window): number => {
         switch (dir) {
-          case "up":
-            return Math.max(window.geometry.maxY, prevValue);
-          case "down":
-            return Math.min(window.geometry.y, prevValue);
-          case "left":
-            return Math.max(window.geometry.maxX, prevValue);
-          case "right":
-            return Math.min(window.geometry.x, prevValue);
+          case 'up':
+            return Math.max(window.geometry.maxY, prevValue)
+          case 'down':
+            return Math.min(window.geometry.y, prevValue)
+          case 'left':
+            return Math.max(window.geometry.maxX, prevValue)
+          case 'right':
+            return Math.min(window.geometry.x, prevValue)
         }
       },
-      dir === "up" || dir === "left" ? 0 : Infinity
-    );
+      dir === 'up' || dir === 'left' ? 0 : Infinity
+    )
   }

   private getClosestRelativeWindow(
@@ -682,54 +683,54 @@ export class EngineImpl implements Engine {
     return windowArray.filter((window): boolean => {
       // adjust closestPoint for potential misalignment of tiled windows
       switch (dir) {
-        case "up":
-          return window.geometry.maxY > closestPoint - 5;
-        case "down":
-          return window.geometry.y < closestPoint + 5;
-        case "left":
-          return window.geometry.maxX > closestPoint - 5;
-        case "right":
-          return window.geometry.x < closestPoint + 5;
+        case 'up':
+          return window.geometry.maxY > closestPoint - 5
+        case 'down':
+          return window.geometry.y < closestPoint + 5
+        case 'left':
+          return window.geometry.maxX > closestPoint - 5
+        case 'right':
+          return window.geometry.x < closestPoint + 5
       }
-    });
+    })
   }

   private getNeighborByDirection(
     basis: EngineWindow,
     dir: Direction
   ): EngineWindow | null {
-    const neighborCandidates = this.getNeighborCandidates(basis, dir);
+    const neighborCandidates = this.getNeighborCandidates(basis, dir)

     if (neighborCandidates.length === 0) {
-      return null;
+      return null
     }

     const closestWindowCorner = this.getClosestRelativWindowCorner(
       neighborCandidates,
       dir
-    );
+    )

     const closestWindows = this.getClosestRelativeWindow(
       neighborCandidates,
       dir,
       closestWindowCorner
-    );
+    )

     // Return the most recently used window
-    return closestWindows.sort((a, b) => b.timestamp - a.timestamp)[0];
+    return closestWindows.sort((a, b) => b.timestamp - a.timestamp)[0]
   }

   public showNotification(text: string, icon?: string, hint?: string): void {
-    this.controller.showNotification(text, icon, hint);
+    this.controller.showNotification(text, icon, hint)
   }

   public showLayoutNotification(): void {
-    const currentLayout = this.currentLayoutOnCurrentSurface();
+    const currentLayout = this.currentLayoutOnCurrentSurface()
     this.controller.showNotification(
       currentLayout.name,
       currentLayout.icon,
       currentLayout.hint
-    );
+    )
   }

   /**
@@ -740,17 +741,25 @@ export class EngineImpl implements Engine {
    *
    * @param workingArea area in which we are allowed to work. @see DriverSurface#workingArea
    * @param layout windows layout used
+   * @param visibleWindows the windows visible in the working area.
    */
-  private getTilingArea(workingArea: Rect, layout: WindowsLayout): Rect {
-    if (this.config.monocleMaximize && layout instanceof MonocleLayout) {
-      return workingArea;
+  private getTilingArea(
+    workingArea: Rect,
+    layout: WindowsLayout,
+    visibleWindows: EngineWindow[]
+  ): Rect {
+    if (
+      (this.config.monocleMaximize && layout instanceof MonocleLayout) ||
+      (visibleWindows.length == 1 && this.config.smartGaps)
+    ) {
+      return workingArea
     } else {
       return workingArea.gap(
         this.config.screenGapLeft,
         this.config.screenGapRight,
         this.config.screenGapTop,
         this.config.screenGapBottom
-      );
+      )
     }
   }
 }
diff --git a/src/kwinscript/engine/layout/three_column_layout.ts b/src/kwinscript/engine/layout/three_column_layout.ts
index db046ad4..d4c0a5a2 100644
--- a/src/kwinscript/engine/layout/three_column_layout.ts
+++ b/src/kwinscript/engine/layout/three_column_layout.ts
@@ -3,10 +3,10 @@
 //
 // SPDX-License-Identifier: MIT

-import { WindowsLayout } from ".";
-import LayoutUtils from "./layout_utils";
+import { WindowsLayout } from '.'
+import LayoutUtils from './layout_utils'

-import { WindowState, EngineWindow } from "../window";
+import { WindowState, EngineWindow } from '../window'

 import {
   Action,
@@ -14,35 +14,39 @@ import {
   DecreaseMasterAreaWindowCount,
   IncreaseLayoutMasterAreaSize,
   IncreaseMasterAreaWindowCount,
-} from "../../controller/action";
+  Rotate,
+  RotateReverse,
+} from '../../controller/action'

-import { partitionArrayBySizes, clip, slide } from "../../util/func";
-import { Rect, RectDelta } from "../../util/rect";
-import { Config } from "../../config";
-import { Controller } from "../../controller";
-import { Engine } from "..";
+import { partitionArrayBySizes, clip, slide } from '../../util/func'
+import { Rect, RectDelta } from '../../util/rect'
+import { Config } from '../../config'
+import { Controller } from '../../controller'
+import { Engine } from '..'

 export default class ThreeColumnLayout implements WindowsLayout {
-  public static readonly MIN_MASTER_RATIO = 0.2;
-  public static readonly MAX_MASTER_RATIO = 0.75;
-  public static readonly id = "ThreeColumnLayout";
-  public readonly classID = ThreeColumnLayout.id;
-  public readonly name = "Three-Column Layout";
-  public readonly icon = "bismuth-column";
+  public static readonly MIN_MASTER_RATIO = 0.2
+  public static readonly MAX_MASTER_RATIO = 0.75
+  public static readonly id = 'ThreeColumnLayout'
+  public readonly classID = ThreeColumnLayout.id
+  public readonly name = 'Three-Column Layout'
+  public readonly icon = 'bismuth-column'

   public get hint(): string {
-    return String(this.masterSize);
+    return String(this.masterSize)
   }

-  private masterRatio: number;
-  private masterSize: number;
+  private masterRatio: number
+  private masterSize: number
+  private horizontal: boolean

-  private config: Config;
+  private config: Config

   constructor(config: Config) {
-    this.config = config;
-    this.masterRatio = 0.6;
-    this.masterSize = 1;
+    this.config = config
+    this.masterRatio = 0.6
+    this.masterSize = 1
+    this.horizontal = true
   }

   public adjust(
@@ -51,14 +55,14 @@ export default class ThreeColumnLayout implements WindowsLayout {
     basis: EngineWindow,
     delta: RectDelta
   ): void {
-    const basisIndex = tiles.indexOf(basis);
+    const basisIndex = tiles.indexOf(basis)
     if (basisIndex < 0) {
-      return;
+      return
     }

     if (tiles.length === 0) {
       /* no tiles */
-      return;
+      return
     } else if (tiles.length <= this.masterSize) {
       /* one column */
       LayoutUtils.adjustAreaWeights(
@@ -66,8 +70,9 @@ export default class ThreeColumnLayout implements WindowsLayout {
         tiles.map((tile) => tile.weight),
         this.config.tileLayoutGap,
         tiles.indexOf(basis),
-        delta
-      ).forEach((newWeight, i) => (tiles[i].weight = newWeight * tiles.length));
+        delta,
+        this.horizontal
+      ).forEach((newWeight, i) => (tiles[i].weight = newWeight * tiles.length))
     } else if (tiles.length === this.masterSize + 1) {
       /* two columns */

@@ -78,69 +83,72 @@ export default class ThreeColumnLayout implements WindowsLayout {
         this.config.tileLayoutGap,
         basisIndex < this.masterSize ? 0 : 1,
         delta,
-        true
-      );
+        true,
+        this.horizontal
+      )

       /* adjust master tile weights */
       if (basisIndex < this.masterSize) {
-        const masterTiles = tiles.slice(0, -1);
+        const masterTiles = tiles.slice(0, -1)
         LayoutUtils.adjustAreaWeights(
           area,
           masterTiles.map((tile) => tile.weight),
           this.config.tileLayoutGap,
           basisIndex,
-          delta
+          delta,
+          this.horizontal
         ).forEach(
           (newWeight, i) =>
             (masterTiles[i].weight = newWeight * masterTiles.length)
-        );
+        )
       }
     } else if (tiles.length > this.masterSize + 1) {
       /* three columns */
-      let basisGroup;
+      let basisGroup
       if (basisIndex < this.masterSize) {
         /* master */
-        basisGroup = 1;
+        basisGroup = 1
       } else if (
         basisIndex < Math.floor((this.masterSize + tiles.length) / 2)
       ) {
         /* R-stack */
-        basisGroup = 2;
+        basisGroup = 2
       } else {
-        basisGroup = 0; /* L-stack */
+        basisGroup = 0 /* L-stack */
       }

       /* adjust master-stack ratio */
-      const stackRatio = 1 - this.masterRatio;
+      const stackRatio = 1 - this.masterRatio
       const newRatios = LayoutUtils.adjustAreaWeights(
         area,
         [stackRatio, this.masterRatio, stackRatio],
         this.config.tileLayoutGap,
         basisGroup,
         delta,
-        true
-      );
-      const newMasterRatio = newRatios[1];
-      const newStackRatio = basisGroup === 0 ? newRatios[0] : newRatios[2];
-      this.masterRatio = newMasterRatio / (newMasterRatio + newStackRatio);
+        this.horizontal
+      )
+      const newMasterRatio = newRatios[1]
+      const newStackRatio = basisGroup === 0 ? newRatios[0] : newRatios[2]
+      this.masterRatio = newMasterRatio / (newMasterRatio + newStackRatio)

       /* adjust tile weight */
-      const rstackNumTile = Math.floor((tiles.length - this.masterSize) / 2);
+      const rstackNumTile = Math.floor((tiles.length - this.masterSize) / 2)
       const [masterTiles, rstackTiles, lstackTiles] =
         partitionArrayBySizes<EngineWindow>(tiles, [
           this.masterSize,
           rstackNumTile,
-        ]);
-      const groupTiles = [lstackTiles, masterTiles, rstackTiles][basisGroup];
+        ])
+      const groupTiles = [lstackTiles, masterTiles, rstackTiles][basisGroup]
       LayoutUtils.adjustAreaWeights(
         area /* we only need height */,
         groupTiles.map((tile) => tile.weight),
         this.config.tileLayoutGap,
         groupTiles.indexOf(basis),
-        delta
+        delta,
+        this.horizontal
       ).forEach(
         (newWeight, i) => (groupTiles[i].weight = newWeight * groupTiles.length)
-      );
+      )
     }
   }

@@ -150,16 +158,17 @@ export default class ThreeColumnLayout implements WindowsLayout {
     area: Rect
   ): void {
     /* Tile all tileables */
-    tileables.forEach((tileable) => (tileable.state = WindowState.Tiled));
-    const tiles = tileables;
+    tileables.forEach((tileable) => (tileable.state = WindowState.Tiled))
+    const tiles = tileables

     if (tiles.length <= this.masterSize) {
       /* only master */
       LayoutUtils.splitAreaWeighted(
         area,
         tiles.map((tile) => tile.weight),
-        this.config.tileLayoutGap
-      ).forEach((tileArea, i) => (tiles[i].geometry = tileArea));
+        this.config.tileLayoutGap,
+        this.horizontal
+      ).forEach((tileArea, i) => (tiles[i].geometry = tileArea))
     } else if (tiles.length === this.masterSize + 1) {
       /* master & R-stack (only 1 window in stack) */
       const [masterArea, stackArea] = LayoutUtils.splitAreaHalfWeighted(
@@ -167,79 +176,84 @@ export default class ThreeColumnLayout implements WindowsLayout {
         this.masterRatio,
         this.config.tileLayoutGap,
         true
-      );
+      )

-      const masterTiles = tiles.slice(0, this.masterSize);
+      const masterTiles = tiles.slice(0, this.masterSize)
       LayoutUtils.splitAreaWeighted(
         masterArea,
         masterTiles.map((tile) => tile.weight),
-        this.config.tileLayoutGap
-      ).forEach((tileArea, i) => (masterTiles[i].geometry = tileArea));
+        this.config.tileLayoutGap,
+        this.horizontal
+      ).forEach((tileArea, i) => (masterTiles[i].geometry = tileArea))

-      tiles[tiles.length - 1].geometry = stackArea;
+      tiles[tiles.length - 1].geometry = stackArea
     } else if (tiles.length > this.masterSize + 1) {
       /* L-stack & master & R-stack */
-      const stackRatio = 1 - this.masterRatio;
+      const stackRatio = 1 - this.masterRatio

       /** Areas allocated to L-stack, master, and R-stack */
       const groupAreas = LayoutUtils.splitAreaWeighted(
         area,
         [stackRatio, this.masterRatio, stackRatio],
         this.config.tileLayoutGap,
-        true
-      );
+        this.horizontal
+      )

-      const rstackSize = Math.floor((tiles.length - this.masterSize) / 2);
+      const rstackSize = Math.floor((tiles.length - this.masterSize) / 2)
       const [masterTiles, rstackTiles, lstackTiles] =
         partitionArrayBySizes<EngineWindow>(tiles, [
           this.masterSize,
           rstackSize,
-        ]);
-      [lstackTiles, masterTiles, rstackTiles].forEach((groupTiles, group) => {
+        ])
+      ;[lstackTiles, masterTiles, rstackTiles].forEach((groupTiles, group) => {
         LayoutUtils.splitAreaWeighted(
           groupAreas[group],
           groupTiles.map((tile) => tile.weight),
-          this.config.tileLayoutGap
-        ).forEach((tileArea, i) => (groupTiles[i].geometry = tileArea));
-      });
+          this.config.tileLayoutGap,
+          this.horizontal
+        ).forEach((tileArea, i) => (groupTiles[i].geometry = tileArea))
+      })
     }
   }

   public clone(): WindowsLayout {
-    const other = new ThreeColumnLayout(this.config);
-    other.masterRatio = this.masterRatio;
-    other.masterSize = this.masterSize;
-    return other;
+    const other = new ThreeColumnLayout(this.config)
+    other.masterRatio = this.masterRatio
+    other.masterSize = this.masterSize
+    return other
   }

   public executeAction(engine: Engine, action: Action): void {
     if (action instanceof IncreaseMasterAreaWindowCount) {
-      this.resizeMaster(engine, +1);
+      this.resizeMaster(engine, +1)
     } else if (action instanceof DecreaseMasterAreaWindowCount) {
-      this.resizeMaster(engine, -1);
+      this.resizeMaster(engine, -1)
     } else if (action instanceof DecreaseLayoutMasterAreaSize) {
       this.masterRatio = clip(
         slide(this.masterRatio, -0.05),
         ThreeColumnLayout.MIN_MASTER_RATIO,
         ThreeColumnLayout.MAX_MASTER_RATIO
-      );
+      )
     } else if (action instanceof IncreaseLayoutMasterAreaSize) {
       this.masterRatio = clip(
         slide(this.masterRatio, +0.05),
         ThreeColumnLayout.MIN_MASTER_RATIO,
         ThreeColumnLayout.MAX_MASTER_RATIO
-      );
+      )
+    } else if (action instanceof Rotate || action instanceof RotateReverse) {
+      this.horizontal = !this.horizontal
+      engine.showLayoutNotification()
     } else {
-      action.executeWithoutLayoutOverride();
+      action.executeWithoutLayoutOverride()
     }
   }

   public toString(): string {
-    return `ThreeColumnLayout(nmaster=${this.masterSize})`;
+    return `ThreeColumnLayout(nmaster=${this.masterSize}, horizontal=${this.horizontal})`
   }

   private resizeMaster(engine: Engine, step: -1 | 1): void {
-    this.masterSize = clip(this.masterSize + step, 1, 10);
-    engine.showLayoutNotification();
+    this.masterSize = clip(this.masterSize + step, 1, 10)
+    engine.showLayoutNotification()
   }
 }
diff --git a/src/kwinscript/engine/layout_store.ts b/src/kwinscript/engine/layout_store.ts
index 8d1e8a68..4bd18db1 100644
--- a/src/kwinscript/engine/layout_store.ts
+++ b/src/kwinscript/engine/layout_store.ts
@@ -3,123 +3,126 @@
 //
 // SPDX-License-Identifier: MIT

-import FloatingLayout from "./layout/floating_layout";
+import FloatingLayout from './layout/floating_layout'

-import { WindowsLayout } from "./layout";
+import { WindowsLayout } from './layout'

-import { DriverSurface } from "../driver/surface";
+import { DriverSurface } from '../driver/surface'

-import { wrapIndex } from "../util/func";
-import { Config } from "../config";
-import MonocleLayout from "./layout/monocle_layout";
-import TileLayout from "./layout/tile_layout";
-import CascadeLayout from "./layout/cascade_layout";
-import QuarterLayout from "./layout/quarter_layout";
-import SpiralLayout from "./layout/spiral_layout";
-import SpreadLayout from "./layout/spread_layout";
-import StairLayout from "./layout/stair_layout";
-import ThreeColumnLayout from "./layout/three_column_layout";
+import { wrapIndex } from '../util/func'
+import { Config } from '../config'
+import MonocleLayout from './layout/monocle_layout'
+import TileLayout from './layout/tile_layout'
+import CascadeLayout from './layout/cascade_layout'
+import QuarterLayout from './layout/quarter_layout'
+import SpiralLayout from './layout/spiral_layout'
+import SpreadLayout from './layout/spread_layout'
+import StairLayout from './layout/stair_layout'
+import ThreeColumnLayout from './layout/three_column_layout'
+import VerticalTileLayout from './layout/vertical_layout'

 export class LayoutStoreEntry {
   public get currentLayout(): WindowsLayout {
-    return this.loadLayout(this.currentID);
+    return this.loadLayout(this.currentID)
   }

-  private currentIndex: number | null;
-  private currentID: string;
-  private layouts: { [key: string]: WindowsLayout };
-  private previousID: string;
+  private currentIndex: number | null
+  private currentID: string
+  private layouts: { [key: string]: WindowsLayout }
+  private previousID: string

-  private config: Config;
+  private config: Config

   constructor(config: Config) {
-    this.config = config;
-    this.currentIndex = 0;
-    this.currentID = this.config.layoutOrder[0];
-    this.layouts = {};
-    this.previousID = this.currentID;
+    this.config = config
+    this.currentIndex = 0
+    this.currentID = this.config.layoutOrder[0]
+    this.layouts = {}
+    this.previousID = this.currentID

-    this.loadLayout(this.currentID);
+    this.loadLayout(this.currentID)
   }

   public cycleLayout(step: -1 | 1): WindowsLayout {
-    this.previousID = this.currentID;
+    this.previousID = this.currentID
     this.currentIndex =
       this.currentIndex !== null
         ? wrapIndex(this.currentIndex + step, this.config.layoutOrder.length)
-        : 0;
-    this.currentID = this.config.layoutOrder[this.currentIndex];
-    return this.loadLayout(this.currentID);
+        : 0
+    this.currentID = this.config.layoutOrder[this.currentIndex]
+    return this.loadLayout(this.currentID)
   }

   public toggleLayout(targetID: string): WindowsLayout {
-    const targetLayout = this.loadLayout(targetID);
+    const targetLayout = this.loadLayout(targetID)

     // Toggle if requested, set otherwise
     if (this.currentID === targetID) {
-      this.currentID = this.previousID;
-      this.previousID = targetID;
+      this.currentID = this.previousID
+      this.previousID = targetID
     } else {
-      this.previousID = this.currentID;
-      this.currentID = targetID;
+      this.previousID = this.currentID
+      this.currentID = targetID
     }

-    this.updateCurrentIndex();
-    return targetLayout;
+    this.updateCurrentIndex()
+    return targetLayout
   }

   private updateCurrentIndex(): void {
-    const idx = this.config.layoutOrder.indexOf(this.currentID);
-    this.currentIndex = idx === -1 ? null : idx;
+    const idx = this.config.layoutOrder.indexOf(this.currentID)
+    this.currentIndex = idx === -1 ? null : idx
   }

   private loadLayout(ID: string): WindowsLayout {
-    let layout = this.layouts[ID];
+    let layout = this.layouts[ID]
     if (!layout) {
-      layout = this.layouts[ID] = this.createLayoutFromId(ID);
+      layout = this.layouts[ID] = this.createLayoutFromId(ID)
     }
-    return layout;
+    return layout
   }

   private createLayoutFromId(id: string): WindowsLayout {
     if (id == MonocleLayout.id) {
-      return new MonocleLayout(this.config);
+      return new MonocleLayout(this.config)
     } else if (id == QuarterLayout.id) {
-      return new QuarterLayout(this.config);
+      return new QuarterLayout(this.config)
     } else if (id == SpiralLayout.id) {
-      return new SpiralLayout(this.config);
+      return new SpiralLayout(this.config)
     } else if (id == SpreadLayout.id) {
-      return new SpreadLayout();
+      return new SpreadLayout()
     } else if (id == StairLayout.id) {
-      return new StairLayout();
+      return new StairLayout()
     } else if (id == ThreeColumnLayout.id) {
-      return new ThreeColumnLayout(this.config);
+      return new ThreeColumnLayout(this.config)
     } else if (id == TileLayout.id) {
-      return new TileLayout(this.config);
+      return new TileLayout(this.config)
+    } else if (id == VerticalTileLayout.id) {
+      return new VerticalTileLayout(this.config)
     } else {
-      return new FloatingLayout();
+      return new FloatingLayout()
     }
   }
 }

 export default class LayoutStore {
-  private store: { [key: string]: LayoutStoreEntry };
+  private store: { [key: string]: LayoutStoreEntry }

   constructor(private config: Config) {
-    this.store = {};
+    this.store = {}
   }

   public getCurrentLayout(srf: DriverSurface): WindowsLayout {
     return srf.ignore
       ? FloatingLayout.instance
-      : this.getEntry(srf.id).currentLayout;
+      : this.getEntry(srf.id).currentLayout
   }

   public cycleLayout(srf: DriverSurface, step: 1 | -1): WindowsLayout | null {
     if (srf.ignore) {
-      return null;
+      return null
     }
-    return this.getEntry(srf.id).cycleLayout(step);
+    return this.getEntry(srf.id).cycleLayout(step)
   }

   public toggleLayout(
@@ -127,15 +130,15 @@ export default class LayoutStore {
     layoutClassID: string
   ): WindowsLayout | null {
     if (surf.ignore) {
-      return null;
+      return null
     }
-    return this.getEntry(surf.id).toggleLayout(layoutClassID);
+    return this.getEntry(surf.id).toggleLayout(layoutClassID)
   }

   private getEntry(key: string): LayoutStoreEntry {
     if (!this.store[key]) {
-      this.store[key] = new LayoutStoreEntry(this.config);
+      this.store[key] = new LayoutStoreEntry(this.config)
     }
-    return this.store[key];
+    return this.store[key]
   }
 }
diff --git a/src/kwinscript/icons/CMakeLists.txt b/src/kwinscript/icons/CMakeLists.txt
index 0c73ca01..a0e99571 100644
--- a/src/kwinscript/icons/CMakeLists.txt
+++ b/src/kwinscript/icons/CMakeLists.txt
@@ -11,6 +11,7 @@ ecm_install_icons(
   16-status-bismuth-spread.svg
   16-status-bismuth-stair.svg
   16-status-bismuth-tile.svg
+  16-status-bismuth-vertical-tile.svg
   32-status-bismuth-column.svg
   32-status-bismuth-floating.svg
   32-status-bismuth-monocle.svg
@@ -19,5 +20,6 @@ ecm_install_icons(
   32-status-bismuth-spread.svg
   32-status-bismuth-stair.svg
   32-status-bismuth-tile.svg
+  32-status-bismuth-vertical-tile.svg
   DESTINATION
   ${KDE_INSTALL_ICONDIR})
